import time as time
import pickle
from PIL import Image
from dijkstar import Graph, find_path

########################
#   HELPER FUNCTIONS   #
########################

def load_color_image(filename):
    """
    Loads a color image from the given file and returns a dictionary
    representing that image.

    Dictionary:
    image = {
        'height': height,
        'width': width,
        'pixels': [0 --> 255 if grayscale else (R,G,B) values],
    }

    Invoked as, for example:
       i = load_color_image('test_images/cat.png')
    """
    with open(filename, 'rb') as img_handle:
        img = Image.open(img_handle)
        img = img.convert('RGB')  # in case we were given a greyscale image
        img_data = img.getdata()
        pixels = list(img_data)
        w, h = img.size
        return {'height': h, 'width': w, 'pixels': pixels}


def save_color_image(image, filename, mode='PNG'):
    """
    Saves the given color image to disk or to a file-like object.  If filename
    is given as a string, the file type will be inferred from the given name.
    If filename is given as a file-like object, the file type will be
    determined by the 'mode' parameter.
    """
    out = Image.new(mode='RGB', size=(image['width'], image['height']))
    out.putdata(image['pixels'])
    if isinstance(filename, str):
        out.save(filename)
    else:
        out.save(filename, mode)
    out.close()


def get_pixel(image, x, y):
    """
    Retrieves value of a pixel at (x,y) of 
    an image dictionary if in bounds, otherwise None
    """
    location = y*image["width"] + x
    return image['pixels'][location] if in_bounds(image, x, y) else None


def set_pixel(image, c, x, y):
    """
    Sets pixel at (x,y) to value c
    """

    location = y*image["width"] + x
    image['pixels'][location] = c


def in_bounds(image, x, y):
    """ 
    Returns bool representing whether (x,y) 
    is in bounds of an image
    """
    return 0 <= x < image["width"] and 0 <= y < image["height"]

direction_vector = {
    "up": (-1, 0),
    "down": (+1, 0),
    "left": (0, -1),
    "right": (0, +1),
}

def get_radial_sweep(image, x, y, r):
    """
    Returns ALL coordinates within r pixels of (x,y) 
    contained within the image
    """
    return [(x + dx, y + dy) 
                for dx in range(-r, r + 1)
                    for dy in range(-r, r + 1) if in_bounds(image, *(x + dx, y + dy))]

def get_acceptable_neighbors(x, y, acceptable_pixels):
    """
    Returns up-down-left-right neighbors of (x,y)
    that are in the set "acceptable_pixels"
    """
    return [(x + dx, y + dy) 
                for dx, dy in direction_vector.values() 
                    if (x + dx, y + dy) in acceptable_pixels]


def get_white_neighbors(image, x, y):
    """
    Returns up-down-left-right neighbors of (x,y)
    that are white/near-white neighbors of 
    a given pixel --> pixel vals > 254)
    """
    return [(x + dx, y + dy) 
                for dx, dy in direction_vector.values() 
                     if in_bounds(image, *(x + dx, y + dy)) 
                        and sum(get_pixel(image, *(x + dx, y + dy) )) > 250*3]

# def get_neighbors_racist(image, x, y):
#     """
#     Returns only neighbors if they're > 5 pixels away from black pixels
#     """
#     result = []
#     for direction in direction_vector:
#         new_coord = (x + direction_vector[direction][0], y + direction_vector[direction][1])

#         if (in_bounds(image, *new_coord) and sum(get_pixel(image, *new_coord)) > 250*3 
#             and all(sum(get_pixel(image, *coord)) > 250*3 for coord in get_coord_box(image, *new_coord))):
            
#             result.append(new_coord)

#     return result


########################
#    PREPROCESSING     #
########################

# def preprocessing_function(image, threshold = 4):
#     """
#     Given an image, returns a set of pixels that 
#     are not within "threshold" pixels of darker pixels
#     (white pixels a good distance away from black pixels)

#     This is to produce a BFS tree w/ paths that don't 
#     hug against walls (to produce more realistic paths)
#     """
#     acceptable_pixels = set()

#     for x in range(1,image['width']):
#         for y in range(1,image['height']):
#             new_coord = (x,y)

#             if (sum(get_pixel(image, *new_coord)) > 250*3 and 
#                 all(sum(get_pixel(image, *coord)) > 250*3 
#                     for coord in get_radial_sweep(image, *new_coord, threshold))):
#                 # add in coordinate only if it itself is white
#                 # and all neighbors 
#                 # in "threshold" pixel radius are white
#                 acceptable_pixels.add(new_coord)

#     return acceptable_pixels            

def get_neighbors(image,x,y):
    return [(x + dx, y + dy) 
                for dx, dy in direction_vector.values() 
                if in_bounds(image, x+dx, y+dy)]

def shortest_distance_black(pixel_coord,image):
    """
    Returns the shortest distance from a pixel in the image to a black pixel
    """
    agenda = [(pixel_coord, 0)] # holds coordinates to explore
    visited = set()

    while agenda:
        curr_node = agenda.pop(0)
        if sum(get_pixel(image,*curr_node[0])) < 3*240:
            return curr_node[1]

        for child in get_neighbors(image, *curr_node[0]):
            if child not in visited:
                agenda.append((child,curr_node[1]+1))
                visited.add(child)

def weight_function(pixel,image,k):
    """
    pass in a constant k
    """
    return k*(1/((shortest_distance_black(pixel,image))**2))

def preprocessing_function_new(image,k):
    """
    k is the weighting value
    """
    graph = Graph()
    
    for x in range(0,image['width']):
        for y in range(0,image['height']):
            for neighbor in get_white_neighbors(image,x,y):
                edge_weight = weight_function(neighbor,image,k)
                graph.add_edge((x,y),neighbor,edge_weight)
    return graph

def get_left_right_neighbors(image,x,y):
    options = [(x+dx,y) for dx in [-1,1] if in_bounds(image,*(x+dx,y))]
    return [option for option in options if sum(get_pixel(image,*option)) > 250*3]

def get_up_down_neighbors(image,x,y):
    options = [(x,y+dy) for dy in [-1,1] if in_bounds(image,*(x,y+dy))]
    return [option for option in options if sum(get_pixel(image,*option)) > 250*3]

def preprocessing_function_duplicate_graph(image,k):
    """
    k is the weighting value
    """
    graph = Graph()

    for x in range(0,image['width']):
        for y in range(0,image['height']):
            for neighbor in get_left_right_neighbors(image,x,y):
                edge_weight = weight_function(neighbor,image,k)
                graph.add_edge((x,y,'horizontal'),(*neighbor,'horizontal'),edge_weight)
            
            for neighbor in get_up_down_neighbors(image,x,y):
                edge_weight = weight_function(neighbor,image,k)
                graph.add_edge((x,y,'vertical'),(*neighbor,'vertical'),edge_weight)
    
    for x in range(0,image['width']):
        for y in range(0,image['height']):
            for neighbor in get_up_down_neighbors(image,x,y):
                edge_weight = k
                graph.add_edge((x,y,'horizontal'),(*neighbor,'vertical'),edge_weight)
            
            for neighbor in get_left_right_neighbors(image,x,y):
                edge_weight = k
                graph.add_edge((x,y,'vertical'),(*neighbor,'horizontal'),edge_weight)
    
    return graph

def cropping_image(image):
    """
    Note that image we take in is our own internal representation

    This functions returns an image object too
    """
    save_color_image(image,'image_temp.png')
    
    with open('image_temp.png', 'rb') as img_handle:
        img = Image.open(img_handle)
        img = img.convert('RGB')  # in case we were given a greyscale image


    def top_down(image):
        for y in range(0,image['height']):
            for x in range(0,image['width']):
                coord = (x,y)
                pixel_value = get_pixel(image,*coord)
                if sum(pixel_value) < 3*250:
                    return y

    def down_top(image):
        for y in range(image['height']-1,0,-1):
            for x in range(image['width']-1,0,-1):
                coord = (x,y)
                pixel_value = get_pixel(image,*coord)
                if sum(pixel_value) < 3*250:
                    return y

    def left_right(image):
        for x in range(0,image['width']):
            for y in range(0,image['height']):
                coord = (x,y)
                pixel_value = get_pixel(image,*coord)
                if sum(pixel_value) < 3*250:
                    return x

    def right_left(image):
        for x in range(image['width']-1,0,-1):
            for y in range(image['height']-1,0,-1):
                coord = (x,y)
                pixel_value = get_pixel(image,*coord)
                if sum(pixel_value) < 3*250:
                    return x
    
    x_min = left_right(image) - 10
    x_max = right_left(image) + 10
    y_min = top_down(image) - 10
    y_max = down_top(image) + 10

    image_final = img.crop((x_min,y_min,x_max,y_max))

    image_final.save("cropped_image.png")

    return load_color_image("cropped_image.png"), "cropped_image.png"

def reduce_resolution(filename):
    # Open the image by specifying the image path.
    filename = "cropped_image.png"
    img_obj = Image.open(filename)

    # Example-1
    size_x, size_y = img_obj.size
    new_size_x, new_size_y = size_x//5, size_y//5
    new_im = img_obj.resize((new_size_x,new_size_y),Image.Resampling.LANCZOS)
    new_im.save("image_reduced_final.png")

    return load_color_image("image_reduced_final.png")

def expanding_nodes(list_of_coords, factor = 25):
    """
    in the lower res cropped image, a pixel of coordinates (100,100) exists
    in the higher res cropped image, this would correspond to either (495,495) --> (500,500) all 25 inclusive

    (0,0) --> (0,0), (0,1) ...

    (1,1) --> (5,5), (5,6) ... 

    """
    multiplying_factor = int(factor**0.5)

    return [(x*multiplying_factor + dx, y*multiplying_factor + dy) 
                for dx in range(0, multiplying_factor)
                    for dy in range(0, multiplying_factor)
                        for (x,y) in list_of_coords]




########################
#         BFS          #
########################

def bfs(image, start):
    """
    Returns BFS tree rooted at a start pixel in the form
    of parent pointers for an image
    """
    tree = {"start": start, "parent_ptrs": {start: start}} 

    parent = tree["parent_ptrs"] # mapping (x1,y1): (x2,y2)
    agenda = [start] # holds coordinates to explore

    while agenda:
        curr_node = agenda.pop(0)

        for child in get_white_neighbors(image, *curr_node):
            if child not in parent: # if unvisited
                parent[child] = curr_node
                agenda.append(child)

    return tree

def build_sp(tree, end, start = None): 
    """
    Builds a shortest path from parent pointers
    """
    if start == None:
        start = tree["start"]

    parent = tree["parent_ptrs"]
    if end not in parent: # end unreachable
        return None
    
    # initialize
    curr_node = end
    path = [end]

    # backtracks from end node via parent pointers
    # until reach start
    while curr_node != start:
        curr_node = parent[curr_node]
        path.append(curr_node)

    return path[::-1]

# def apsp(image, sources):
#     """
#     Runs APSP on an image given a 
#     representative set of sources 
#     """
#     parent = {}
#     for src in sources:
#         parent[src] = bfs(image, src)
    
#     return parent

def save_image_with_path_drawn(image_name, new_name, relevant_pixels):
    """
    Colors all pixels in "relevant pixels" RED 
    on a copy of an image and saves the new image
    w/ a path drawn
    """
    im_copy = load_color_image(f"{image_name}") # create copy of image
    
    for pixel in relevant_pixels:

        set_pixel(im_copy, (255,0,0), *pixel) # color red
    
    save_color_image(im_copy, new_name)


########################
#       VK TEST        #
########################

def run_Dijkstar_algorithm(graph,start,end):
    """
    Runs our package
    """
    return find_path(graph,start,end)[0]

def run_Dijkstar_algorithm_graph_duplication(graph,start,end):
    """
    Runs our package on the duplicated graph
    """

    start_A = (*start,'horizontal')
    start_B = (*start,'vertical')
    end_A = (*end,'horizontal')
    end_B = (*end,'vertical')

    options = [find_path(graph,start,end) 
                    for start in [start_A, start_B] 
                        for end in [end_A,end_B]]

    to_return =  min(options,key = lambda x: x[3])[0]

    return [(node[0],node[1]) for node in to_return]

########################
#        TESTING       #
########################
def test_bfs(floor_plan, batch, start_coords):
    """
    Runs BFS from given start coordinates
    on an image and saves BFS tree (parent dict.) to 
    a pickle file
    """
    DIRECTORY = f"{floor_plan}_test"
    im_filepath = f"{DIRECTORY}/{floor_plan}_reduced.png"
    image = load_color_image(im_filepath)

    for test_num, start_coord in enumerate(start_coords):
        start_t = time.perf_counter()
        parent = bfs(image, start_coord)
        print(f"BFS test {test_num} time: {time.perf_counter() - start_t}")

        # Draw BFS tree
        save_image_with_path_drawn(im_filepath, f"{DIRECTORY}/{floor_plan}_bfs.png", parent["parent_ptrs"])

        # Save pickle file
        pickle_name = f"{DIRECTORY}/{floor_plan}_batch{batch}_{test_num}.pickle"

        
        with open(pickle_name, "wb") as f:
            pickle.dump(parent, f)


def test_paths(floor_plan, pickle_batch, test_batch, test_num, end_coords):
    """
    Saves PNGs w/ shortest path drawn given a BFS tree
    and a list of destination coordinates
    """
    DIRECTORY = f"{floor_plan}_test"
    pickle_name = f"{DIRECTORY}/{floor_plan}_batch{pickle_batch}_{test_num}.pickle"
    im_filepath = f"{DIRECTORY}/{floor_plan}_reduced.png"

    with open(pickle_name, "rb") as f: # unpickle
        tree = pickle.load(f)
    
    for test_num, end_coord in enumerate(end_coords):
        path = build_sp(tree, end_coord)
        start = tree["start"]
        save_image_with_path_drawn(im_filepath, f"{DIRECTORY}/{floor_plan}_sp_{start}_batch{test_batch}_{test_num}.png", path)


def ask_for_coords(coords):
    """
    Appends user-given coordinates to given list
    """
    user = ""
    while user != "done":
        user = input("Type in coordinates (ex. 120 150): ")
        try:
            coord = tuple(int(num) for num in user.split())
            coords.append(coord)
        except ValueError as e:
            pass


def test():
    # PRODUCING PICKLE FILES
    floor_plan = input("Floor plan? : ") 
    batch = input("Batch? : ")

    # Grab source coordinates for BFS
    start_coords = []
    ask_for_coords(start_coords)
    test_bfs(floor_plan, batch, start_coords)


    # DRAWING PATHS FROM PICKLE FILES
    floor_plan = input("Floor plan? : ") 
    pickle_batch = input("Pickle batch? : ")
    test_batch = input("Test batch? : ")
    test_num = input("Pickle test number? : ")

    # Grab destination coordinates
    end_coords = []
    ask_for_coords(end_coords)
    test_paths(floor_plan, pickle_batch, test_batch, test_num, end_coords)


# image = load_color_image('floorplantest_sp_atrium.png')
# new_rep = cropping_image(image)
# reduce_resolution("cropped_image.png")

def full_algorithm_test(floorplan,start,end):
    """
    STEPS:
    1. Load the filename into our own representation of an image
    2. Crop the image
    3. Reduce its resolution
    4. Run preprocessing/graph creation
    5. Run Djikstar and receive the list of nodes
    6. Expand the list of nodes we receive from Djikstar
    7. Draw this list of nodes onto our original image
    """
    print("we have started")
    start_time = time.perf_counter()
    image = load_color_image(floorplan)
    original_rep, filename = cropping_image(image)
    reduced_rep = reduce_resolution(filename)
    graph = preprocessing_function_duplicate_graph(reduced_rep,25)
    with open("graph_storage.pickle","wb") as f:
        pickle.dump(graph,f)

    preprocessing_complete_time = time.perf_counter()
    print("preprocessing_time: ",preprocessing_complete_time-start_time)
    start_reduced = (start[0]//5,start[1]//5)
    end_reduced = (end[0]//5,end[1]//5)
    low_res_list_nodes = run_Dijkstar_algorithm_graph_duplication(graph,start_reduced,end_reduced)
    high_res_list_nodes = expanding_nodes(low_res_list_nodes)
    save_image_with_path_drawn(filename,"FINAL_RESULT.png",high_res_list_nodes)
    all_complete_time = time.perf_counter()
    print("user_interface_time: ",all_complete_time-preprocessing_complete_time)
    print("we have ended")

def user_algorithm_test(floorplan, pickled_file,start,end):
    start_time = time.perf_counter()

    with open("graph_storage.pickle","rb") as f:
        graph = pickle.load(f)

    image = load_color_image(floorplan)
    original_rep, filename = cropping_image(image)
    start_reduced = (start[0]//5,start[1]//5)
    end_reduced = (end[0]//5,end[1]//5)
    low_res_list_nodes = run_Dijkstar_algorithm_graph_duplication(graph,start_reduced,end_reduced)
    high_res_list_nodes = expanding_nodes(low_res_list_nodes)
    save_image_with_path_drawn(filename,"FINAL_RESULT_testing.png",high_res_list_nodes)

    end_time = time.perf_counter()

    print("user_interface_time is: ",end_time - start_time)


if __name__ == "__main__":
    # full_algorithm_test('floorplantest_sp_atrium.png',(250,125),(930,990))
    # user_algorithm_test('floorplantest_sp_atrium.png','graph_storage.pickle',(241,136),(930,990))
    full_algorithm_test('1_2_floorplan.png',(175,200),(1000,1462))











# if __name__ == "__main__":
#     image_name = 'floorplantest_sp_atrium.png'
#     new_name = 'atrium_copy_reduced.png'
#     image = load_color_image(image_name)

#     start = (72,36)
#     end = (280,300)
#     print("we have started")
#     start_time = time.time()
#     graph = preprocessing_function_new(image,1)
#     end_time = time.time()
#     print("Preprocessing graph time: ",end_time - start_time)
#     relevant_pixels = run_Dijkstar_algorithm(graph,start,end)
#     end_time_final = time.time()
#     save_image_with_path_drawn(image_name, new_name, relevant_pixels)
#     print("Running Dijkstra's Algorithm time: ",end_time_final - end_time)
#     print("we have finished")
#     pass

### Today's agenda:
# 1) Do the resolution stuff
# Algorithmically reduce image resolution (pretty fast)
# Do preprocessing on reduce image (about 10 mins)
# Run our shortest path algorithm (user side -- 0.1 seconds)
# Take the pixels generated (relevant_pixels) (very fast)
# Reexpand these by a factor of ___ on the ORIGINAL IMAGE (very fast)

# 2) Figure out a way to save our preprocessing data

# 
